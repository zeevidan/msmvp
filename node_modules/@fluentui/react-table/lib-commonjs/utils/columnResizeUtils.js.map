{"version":3,"sources":["../src/utils/columnResizeUtils.ts"],"sourcesContent":["import { TableColumnDefinition, ColumnWidthState, TableColumnId, TableColumnSizingOptions } from '../hooks';\n\nconst DEFAULT_WIDTH = 150;\nconst DEFAULT_MIN_WIDTH = 100;\n\n/**\n * This function takes the column definitions and the curent ColumnWidthState and returns new state.\n *  - It uses existing state for existing columns.\n *  - It removes any state for columns no longer present.\n *  - It checks if any column has been replaced and returns updated state if so\n *  - It returns old state if no changes in the state have been made (so that react doesn't call effects)\n * @param columns\n * @param state\n * @returns\n */\n\nexport function columnDefinitionsToState<T>(\n  columns: TableColumnDefinition<T>[],\n  state: ColumnWidthState[] = [],\n  columnSizingOptions: TableColumnSizingOptions = {},\n): ColumnWidthState[] {\n  let updated = false;\n  const stateMap = new Map(state.map(s => [s.columnId, s]));\n\n  const updatedState = columns.map(column => {\n    const existingColumnState = stateMap.get(column.columnId);\n\n    if (existingColumnState) {\n      const {\n        idealWidth = existingColumnState.idealWidth,\n        minWidth = existingColumnState.minWidth,\n        padding = existingColumnState.padding,\n      } = columnSizingOptions[column.columnId] ?? {};\n\n      if (\n        idealWidth !== existingColumnState.idealWidth ||\n        minWidth !== existingColumnState.minWidth ||\n        padding !== existingColumnState.padding\n      ) {\n        updated = true;\n        return {\n          ...existingColumnState,\n          idealWidth,\n          width: idealWidth,\n          minWidth,\n          padding,\n        };\n      }\n      return existingColumnState;\n    }\n\n    const {\n      defaultWidth,\n      idealWidth = DEFAULT_WIDTH,\n      minWidth = DEFAULT_MIN_WIDTH,\n      padding,\n    } = columnSizingOptions[column.columnId] ?? {};\n\n    updated = true;\n    return {\n      columnId: column.columnId,\n      width: Math.max(defaultWidth ?? idealWidth, minWidth),\n      minWidth,\n      idealWidth: Math.max(defaultWidth ?? idealWidth, minWidth),\n      padding: padding ?? 16,\n    };\n  });\n\n  // If the length of the new state changed (column was added or removed) or any of\n  // the individual states has a new reference (column was replaced),\n  // we have to reset the column widths to their ideal width (because the column which was last may not be last now).\n  // Then the adjustColumnWidthsToFitContainer can do its job and properly stretch the last column.\n  if (updatedState.length !== state.length || updated) {\n    const column = updatedState.find(col => col.width > col.idealWidth);\n    if (column) {\n      column.width = column.idealWidth;\n    }\n\n    updated = true;\n  }\n\n  return updated ? updatedState : state;\n}\n\nexport function getColumnById(state: ColumnWidthState[], columnId: TableColumnId) {\n  return state.find(c => c.columnId === columnId);\n}\n\nexport function getColumnByIndex(state: ColumnWidthState[], index: number) {\n  return state[index];\n}\n\nexport function getTotalWidth(state: ColumnWidthState[]): number {\n  return state.reduce((sum, column) => sum + column.width + column.padding, 0);\n}\n\nexport function getLength(state: ColumnWidthState[]) {\n  return state.length;\n}\n\nexport function getColumnWidth(state: ColumnWidthState[], columnId: TableColumnId): number {\n  const column = getColumnById(state, columnId);\n  return column?.width ?? 0;\n}\n\n/**\n * This function takes the current state and returns an updated state, so that it can be set.\n * The reason for this is that we can update the state multiple times before commiting to render.\n * This is an optimization and also prevents flickering.\n * It also returns new copy of the state only if the value is different than the one currently in\n * the state, further preventing unnecessary updates.\n * @param localState\n * @param columnId\n * @param property\n * @param value\n * @returns\n */\nexport function setColumnProperty(\n  localState: ColumnWidthState[],\n  columnId: TableColumnId,\n  property: keyof ColumnWidthState,\n  value: number,\n) {\n  const currentColumn = getColumnById(localState, columnId);\n\n  if (!currentColumn || currentColumn?.[property] === value) {\n    return localState;\n  }\n\n  const updatedColumn = { ...currentColumn, [property]: value };\n\n  const newState = localState.reduce((acc, current) => {\n    if (current.columnId === updatedColumn.columnId) {\n      return [...acc, updatedColumn];\n    }\n    return [...acc, current];\n  }, [] as ColumnWidthState[]);\n\n  return newState;\n}\n\n/**\n * This function takes the state and container width and makes sure the each column in the state\n * is its optimal width, and that the columns\n * a) fit to the container\n * b) always fill the whole container\n * @param state\n * @param containerWidth\n * @returns\n */\nexport function adjustColumnWidthsToFitContainer(state: ColumnWidthState[], containerWidth: number) {\n  let newState = state;\n  const totalWidth = getTotalWidth(newState);\n\n  // The total width is smaller, we are expanding columns\n  if (totalWidth < containerWidth) {\n    let difference = containerWidth - totalWidth;\n    let i = 0;\n    // We start at the beginning and assign the columns their ideal width\n    while (i < newState.length && difference > 0) {\n      const currentCol = getColumnByIndex(newState, i);\n      const colAdjustment = Math.min(currentCol.idealWidth - currentCol.width, difference);\n      newState = setColumnProperty(newState, currentCol.columnId, 'width', currentCol.width + colAdjustment);\n      difference -= colAdjustment;\n\n      // if there is still empty space, after all columns are their ideal sizes, assign it to the last column\n      if (i === newState.length - 1 && difference !== 0) {\n        const lastCol = getColumnByIndex(newState, i);\n        newState = setColumnProperty(newState, lastCol.columnId, 'width', lastCol.width + difference);\n      }\n\n      i++;\n    }\n  }\n\n  // The total width is larger than container, we need to squash the columns\n  else if (totalWidth >= containerWidth) {\n    let difference = totalWidth - containerWidth;\n    // We start with the last column\n    let j = newState.length - 1;\n    while (j >= 0 && difference > 0) {\n      const currentCol = getColumnByIndex(newState, j);\n      if (currentCol.width > currentCol.minWidth) {\n        const colAdjustment = Math.min(currentCol.width - currentCol.minWidth, difference);\n        difference -= colAdjustment;\n        newState = setColumnProperty(newState, currentCol.columnId, 'width', currentCol.width - colAdjustment);\n      }\n      j--;\n    }\n  }\n\n  return newState;\n}\n"],"names":["adjustColumnWidthsToFitContainer","columnDefinitionsToState","getColumnById","getColumnByIndex","getColumnWidth","getLength","getTotalWidth","setColumnProperty","DEFAULT_WIDTH","DEFAULT_MIN_WIDTH","columns","state","columnSizingOptions","updated","stateMap","Map","map","s","columnId","updatedState","column","existingColumnState","get","idealWidth","minWidth","padding","width","defaultWidth","Math","max","length","find","col","c","index","reduce","sum","localState","property","value","currentColumn","updatedColumn","newState","acc","current","containerWidth","totalWidth","difference","i","currentCol","colAdjustment","min","lastCol","j"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}