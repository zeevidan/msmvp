{"version":3,"sources":["../src/hooks/useIntersectionObserver.ts"],"sourcesContent":["import * as React from 'react';\nimport { useIsomorphicLayoutEffect } from '@fluentui/react-utilities';\nimport { useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';\n\nconst { useCallback, useState, useRef } = React;\nimport { useMutationObserver } from './useMutationObserver';\n\n/**\n * This function will take the rootMargin and flip the sides if we are in RTL based on the computed reading direction of the target element.\n * @param ltrRootMargin the margin to be processed and flipped if required\n * @param target target element that will have its current reading direction determined\n * @returns the corrected rootMargin (if it was necessary to correct)\n */\nexport const getRTLRootMargin = (\n  ltrRootMargin: string,\n  target?: Element | Document | null | undefined,\n  win?: Window | null,\n): string => {\n  if (target && win) {\n    // get the computed dir for the target element\n    const newDir = win.getComputedStyle(target as Element).direction;\n\n    // If we're in rtl reading direction, we might need to flip the margins on the left/right sides\n    if (newDir === 'rtl') {\n      let newMargin = ltrRootMargin;\n      const splitMargins = ltrRootMargin.split(' ');\n\n      // We only need to do this if we get four values, otherwise the sides are equal and don't require flipping.\n      if (splitMargins.length === 4) {\n        newMargin = `${splitMargins[0]} ${splitMargins[3]} ${splitMargins[2]} ${splitMargins[1]}`;\n      }\n\n      return newMargin;\n    } else {\n      return ltrRootMargin;\n    }\n  }\n\n  return ltrRootMargin;\n};\n\n/**\n * React hook that allows easy usage of the browser API IntersectionObserver within React\n * @param callback - A function called when the percentage of the target element is visible crosses a threshold.\n * @param options - An optional object which customizes the observer. If options isn't specified, the observer uses the\n * document's viewport as the root, with no margin, and a 0% threshold (meaning that even a one-pixel change is\n * enough to trigger a callback).\n * @returns An array containing a callback to update the list of Elements the observer should listen to, a callback to\n * update the init options of the IntersectionObserver and a ref to the IntersectionObserver instance itself.\n */\n\nexport const useIntersectionObserver = (\n  callback: IntersectionObserverCallback,\n  options?: IntersectionObserverInit,\n): {\n  setObserverList: React.Dispatch<React.SetStateAction<Element[] | undefined>>;\n  setObserverInit: (newInit: IntersectionObserverInit | undefined) => void;\n  // TODO: exclude types from this lint rule: https://github.com/microsoft/fluentui/issues/31286\n  // eslint-disable-next-line no-restricted-globals\n  observer: React.MutableRefObject<IntersectionObserver | undefined>;\n} => {\n  'use no memo';\n\n  // TODO: exclude types from this lint rule: https://github.com/microsoft/fluentui/issues/31286\n  // eslint-disable-next-line no-restricted-globals\n  const observer = useRef<IntersectionObserver>();\n  const [observerList, setObserverList] = useState<Element[]>();\n  const { targetDocument } = useFluent();\n  const win = targetDocument?.defaultView;\n\n  // set the initial init with corrected margins based on the observed root's calculated reading direction.\n  const [observerInit, setObserverInit] = useState<IntersectionObserverInit | undefined>(\n    options && {\n      ...options,\n      rootMargin: getRTLRootMargin(options.rootMargin ?? '0px', options.root as Element, win),\n    },\n  );\n\n  // We have to assume that any values passed in for rootMargin by the consuming app are ltr values. As such we will store the ltr value.\n  const ltrRootMargin = useRef<string>(options?.rootMargin ?? '0px');\n\n  // Callback function to execute when mutations are observed\n  const mutationObserverCallback: MutationCallback = useCallback(\n    mutationList => {\n      for (const mutation of mutationList) {\n        // Ensuring that the right attribute is being observed and that the root is within the tree of the element being mutated.\n        if (\n          mutation.type === 'attributes' &&\n          mutation.attributeName === 'dir' &&\n          options?.root &&\n          mutation.target.contains(options?.root)\n        ) {\n          setObserverInit({\n            ...observerInit,\n            rootMargin: getRTLRootMargin(ltrRootMargin.current, observerInit?.root, win),\n          });\n        }\n      }\n    },\n    [ltrRootMargin, observerInit, options?.root, win],\n  );\n\n  // Mutation observer for dir attribute changes in the document\n  useMutationObserver(targetDocument, mutationObserverCallback, {\n    attributes: true,\n    subtree: true,\n    attributeFilter: ['dir'],\n  });\n\n  // Observer elements in passed in list and clean up previous list\n  // This effect is only triggered when observerList is updated\n  useIsomorphicLayoutEffect(() => {\n    if (!win) {\n      return;\n    }\n\n    observer.current = new win.IntersectionObserver(callback, {\n      ...observerInit,\n      rootMargin: getRTLRootMargin(ltrRootMargin.current, observerInit?.root, win),\n    });\n\n    // If we have an instance of IO and a list with elements, observer the elements\n    if (observer.current && observerList && observerList.length > 0) {\n      observerList.forEach(element => {\n        observer.current?.observe(element);\n      });\n    }\n\n    // clean up previous elements being listened to\n    return () => {\n      if (observer.current) {\n        observer.current.disconnect();\n      }\n    };\n  }, [observerList, observerInit, callback, win]);\n\n  // Do not use internally, we need to track external settings only here\n  const setObserverInitExternal = useCallback(\n    (newInit: IntersectionObserverInit | undefined) => {\n      // Since we know this is coming from consumers, we can store this value as LTR somewhat safely.\n      ltrRootMargin.current = newInit?.rootMargin ?? '0px';\n\n      // Call the internal setter to update the value and ensure if our calculated direction is rtl, we flip the margin\n      setObserverInit({\n        ...newInit,\n        rootMargin: getRTLRootMargin(ltrRootMargin.current, newInit?.root as Element, win),\n      });\n    },\n    [ltrRootMargin, setObserverInit, win],\n  );\n\n  return { setObserverList, setObserverInit: setObserverInitExternal, observer };\n};\n"],"names":["getRTLRootMargin","useIntersectionObserver","useCallback","useState","useRef","React","ltrRootMargin","target","win","newDir","getComputedStyle","direction","newMargin","splitMargins","split","length","callback","options","observer","observerList","setObserverList","targetDocument","useFluent","defaultView","observerInit","setObserverInit","rootMargin","root","mutationObserverCallback","mutationList","mutation","type","attributeName","contains","current","useMutationObserver","attributes","subtree","attributeFilter","useIsomorphicLayoutEffect","IntersectionObserver","forEach","element","observe","disconnect","setObserverInitExternal","newInit"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}