{"version":3,"sources":["../src/components/Virtualizer/Virtualizer.types.ts"],"sourcesContent":["import * as React from 'react';\nimport type { ComponentProps, ComponentState, Slot } from '@fluentui/react-utilities';\nimport type { VirtualizerContextProps } from '../../Utilities';\n\nexport type VirtualizerSlots = {\n  /**\n   * The intersection observed 'before' element will detect when scrolling towards the beginning.\n   */\n  before: NonNullable<Slot<'div', 'td'>>;\n  /**\n   * A block place holding whitespace at the beginning of current DOM children.\n   */\n  beforeContainer: NonNullable<Slot<'div', 'tr'>>;\n  /**\n   * The intersection observed 'after' element will detect when scrolling towards the end.\n   */\n  after: NonNullable<Slot<'div', 'td'>>;\n  /**\n   * A block place holding whitespace after the end of current DOM children.\n   */\n  afterContainer: NonNullable<Slot<'div', 'tr'>>;\n};\n\nexport type VirtualizerConfigState = {\n  /**\n   * The current virtualized array of children to show in the DOM.\n   */\n  virtualizedChildren: React.ReactNode[];\n  /**\n   * The current start index for the virtualizer, all previous index's will be removed from DOM.\n   */\n  virtualizerStartIndex: number;\n  /**\n   * Current buffer height required at beginning of array.\n   */\n  afterBufferHeight: number;\n  /**\n   * Current buffer height required at end of array.\n   */\n  beforeBufferHeight: number;\n  /**\n   * The total current height of the scrollView/child content.\n   */\n  totalVirtualizerHeight: number;\n  /**\n   * The scroll direction\n   * @default vertical\n   */\n  axis?: 'vertical' | 'horizontal';\n  /**\n   * Tells the virtualizer to measure in the reverse direction (for column-reverse order etc.)\n   */\n  reversed?: boolean;\n  /**\n   * Enables the isScrolling property in the child render function\n   * Default: false - to prevent nessecary render function calls\n   */\n  enableScrollLoad?: boolean;\n  /**\n   * Pixel size of intersection observers and how much they 'cross over' into the bufferItems index.\n   * Minimum 1px.\n   */\n  bufferSize: number;\n  /**\n   * Ref for access to internal size knowledge, can be used to measure updates\n   */\n  childSizes: React.MutableRefObject<number[]>;\n  /**\n   * Ref for access to internal progressive size knowledge, can be used to measure updates\n   */\n  childProgressiveSizes: React.MutableRefObject<number[]>;\n};\n\nexport type VirtualizerState = ComponentState<VirtualizerSlots> & VirtualizerConfigState;\n\n/**\n * The main child render method of Virtualization\n * isScrolling will only be enabled when enableScrollLoad is set to true.\n */\nexport type VirtualizerChildRenderFunction = (index: number, isScrolling: boolean) => React.ReactNode;\n\nexport type VirtualizerDataRef = {\n  progressiveSizes: React.RefObject<number[]>;\n  nodeSizes: React.RefObject<number[]>;\n  setFlaggedIndex: (index: number | null) => void;\n  currentIndex: React.RefObject<number>;\n};\n\nexport type VirtualizerConfigProps = {\n  /**\n   * Child render function.\n   * Iteratively called to return current virtualizer DOM children.\n   * Will act as a row or column indexer depending on Virtualizer settings.\n   * Can be used dynamically.\n   */\n  children: VirtualizerChildRenderFunction;\n\n  /**\n   * Default cell size to use if no custom callback provided.\n   * If implementing `getItemSize` this should be the initial and ideally minimum cell size.\n   */\n  itemSize: number;\n\n  /**\n   * The total number of items to be virtualized.\n   */\n  numItems: number;\n\n  /**\n   * Number of children to render in the DOM during virtualization.\n   * Constraints:\n   * - Large enough that the items rendered in DOM cover the viewport\n   *   and intersection observer buffers (buffersize) at both ends.\n   */\n  virtualizerLength: number;\n\n  /**\n   * Defaults to 1/4th (or 1/3rd for dynamic items) of virtualizerLength.\n   * RECOMMEND: Override this with a consistent value if using a dynamic virtualizer.\n   *\n   * Controls the number of elements rendered before the current index entering the virtualized viewport.\n   * Constraints:\n   * - Large enough to cover bufferSize (prevents buffers intersecting into the viewport during rest state).\n   * - Small enough that the virtualizer only renders a few items outside of view.\n   */\n  bufferItems?: number;\n\n  /**\n   * Defaults to half of bufferItems * itemSize size (in pixels).\n   * RECOMMEND: Override this with a consistent minimum item size value if using a dynamic virtualizer.\n   * The length (in pixels) before the end/start DOM index where the virtualizer recalculation will be triggered.\n   * Increasing this reduces whitespace on ultra-fast scroll, as additional elements\n   * are buffered to appear while virtualization recalculates.\n   * Constraints:\n   * - At least 1px - although this will only trigger the recalculation after bookends (whitespace) enter viewport.\n   * - BufferSize must be smaller than bufferItems pixel size, as it prevents bookends entering viewport at rest.\n   */\n  bufferSize?: number;\n\n  /**\n   * Enables users to override the intersectionObserverRoot.\n   * We recommend passing this in for accurate distance assessment in IO\n   */\n  scrollViewRef?: React.MutableRefObject<HTMLElement | null>;\n\n  /**\n   * The scroll direction\n   * @default vertical\n   */\n  axis?: 'vertical' | 'horizontal';\n\n  /**\n   * Tells the virtualizer to measure in the reverse direction (for column-reverse order etc.)\n   * This value should be flipped in RTL implementation (TBD whether automate RTL).\n   */\n  reversed?: boolean;\n\n  /**\n   * Enables the isScrolling property in the child render function\n   * Default: false - to prevent nessecary render function calls\n   */\n  enableScrollLoad?: boolean;\n\n  /**\n   * Callback for acquiring size of individual items\n   * @param index - the index of the requested size's child\n   */\n  getItemSize?: (index: number) => number;\n\n  /**\n   * Virtualizer context can be passed as a prop for extended class use\n   */\n  virtualizerContext?: VirtualizerContextProps;\n\n  /**\n   * Callback for notifying when a flagged index has been rendered\n   */\n  // eslint-disable-next-line @nx/workspace-consistent-callback-type -- can't change type of existing callback\n  onRenderedFlaggedIndex?: (index: number) => void;\n\n  /*\n   * Callback for notifying when a flagged index has been rendered\n   */\n  flaggedIndex?: React.MutableRefObject<number | null>;\n\n  /**\n   * Imperative ref contains our scrollTo index functionality for user control.\n   */\n  imperativeVirtualizerRef?: React.RefObject<VirtualizerDataRef>;\n\n  /**\n   * A ref that provides the size of container (vertical - height, horizontal - width), set by a resize observer.\n   * Virtualizer Measure hooks provide a suitable reference.\n   */\n  containerSizeRef: React.RefObject<number>;\n\n  /**\n   * A callback that enables updating scroll position for calculating required dynamic lengths,\n   * this should be passed in from useDynamicVirtualizerMeasure\n   */\n  updateScrollPosition?: (position: number) => void;\n\n  /**\n   * Spacing between rendered children for calculation, should match the container's gap CSS value.\n   */\n  gap?: number;\n};\n\nexport type VirtualizerProps = ComponentProps<Partial<VirtualizerSlots>> & VirtualizerConfigProps;\n"],"names":["React"],"rangeMappings":"","mappings":"AAAA,YAAYA,WAAW,QAAQ"}