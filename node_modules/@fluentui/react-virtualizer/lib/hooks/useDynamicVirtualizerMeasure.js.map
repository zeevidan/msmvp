{"version":3,"sources":["../src/hooks/useDynamicVirtualizerMeasure.ts"],"sourcesContent":["import { useIsomorphicLayoutEffect, useMergedRefs } from '@fluentui/react-utilities';\nimport * as React from 'react';\nimport { VirtualizerMeasureDynamicProps } from './hooks.types';\nimport { useResizeObserverRef_unstable } from './useResizeObserverRef';\nimport { useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';\n\n/**\n * React hook that measures virtualized space dynamically to ensure optimized virtualization length.\n */\nexport const useDynamicVirtualizerMeasure = <TElement extends HTMLElement>(\n  virtualizerProps: VirtualizerMeasureDynamicProps,\n): {\n  virtualizerLength: number;\n  bufferItems: number;\n  bufferSize: number;\n  scrollRef: (instance: TElement | null) => void;\n  containerSizeRef: React.RefObject<number>;\n  updateScrollPosition: (scrollPosition: number) => void;\n} => {\n  const {\n    defaultItemSize,\n    direction = 'vertical',\n    numItems,\n    getItemSize,\n    bufferItems,\n    bufferSize,\n    virtualizerContext,\n  } = virtualizerProps;\n\n  const [state, setState] = React.useState({\n    virtualizerLength: 0,\n    virtualizerBufferItems: 0,\n    virtualizerBufferSize: 0,\n  });\n\n  const containerSizeRef = React.useRef<number>(0);\n  const scrollPosition = React.useRef<number>(0);\n  const { virtualizerLength, virtualizerBufferItems, virtualizerBufferSize } = state;\n\n  const { targetDocument } = useFluent();\n  const container = React.useRef<HTMLElement | null>(null);\n  const handleScrollResize = React.useCallback(\n    (scrollRef: React.MutableRefObject<HTMLElement | null>) => {\n      if (!scrollRef?.current) {\n        // Error? ignore?\n        return;\n      }\n\n      if (scrollRef.current !== targetDocument?.body) {\n        // We have a local scroll container\n        containerSizeRef.current =\n          direction === 'vertical'\n            ? scrollRef?.current.getBoundingClientRect().height\n            : scrollRef?.current.getBoundingClientRect().width;\n      } else if (targetDocument?.defaultView) {\n        // If our scroll ref is the document body, we should check window height\n        containerSizeRef.current =\n          direction === 'vertical' ? targetDocument?.defaultView?.innerHeight : targetDocument?.defaultView?.innerWidth;\n      }\n\n      let indexSizer = 0;\n      let i = 0;\n      let length = 0;\n\n      const startIndex = virtualizerContext.contextIndex;\n      const sizeToBeat = containerSizeRef.current + virtualizerBufferSize * 2;\n\n      while (indexSizer <= sizeToBeat && i + startIndex < numItems) {\n        const iItemSize = getItemSize(startIndex + i);\n        if (virtualizerContext.childProgressiveSizes.current.length < numItems) {\n          /* We are in unknown territory, either an initial render or an update\n            in virtualizer item length has occurred.\n            We need to let the new items render first then we can accurately assess.*/\n          return virtualizerLength - virtualizerBufferSize * 2;\n        }\n\n        const currentScrollPos = scrollPosition.current;\n        const currentItemPos = virtualizerContext.childProgressiveSizes.current[startIndex + i] - iItemSize;\n\n        if (currentScrollPos > currentItemPos + iItemSize) {\n          // The item isn't in view, ignore for now.\n          i++;\n          continue;\n        } else if (currentScrollPos > currentItemPos) {\n          // The item is partially out of view, ignore the out of bounds portion\n          const variance = currentItemPos + iItemSize - currentScrollPos;\n          indexSizer += variance;\n        } else {\n          // Item is in view\n          indexSizer += iItemSize;\n        }\n        // Increment\n        i++;\n        length++;\n      }\n\n      /*\n       * Number of items to append at each end, i.e. 'preload' each side before entering view.\n       * Minimum: 2 - we give slightly more buffer for dynamic version.\n       */\n      const newBufferItems = bufferItems ?? Math.max(Math.ceil(length / 3), 1);\n\n      /*\n       * This is how far we deviate into the bufferItems to detect a redraw.\n       */\n      const newBufferSize = bufferSize ?? Math.max(defaultItemSize / 2, 1);\n      const totalLength = length + newBufferItems * 2;\n\n      setState({\n        virtualizerLength: totalLength,\n        virtualizerBufferSize: newBufferSize,\n        virtualizerBufferItems: newBufferItems,\n      });\n    },\n    [\n      bufferItems,\n      bufferSize,\n      defaultItemSize,\n      direction,\n      getItemSize,\n      numItems,\n      targetDocument?.body,\n      targetDocument?.defaultView,\n      virtualizerBufferSize,\n      virtualizerContext.childProgressiveSizes,\n      virtualizerContext.contextIndex,\n      virtualizerLength,\n    ],\n  );\n\n  const resizeCallback = React.useCallback(\n    (\n      _entries: ResizeObserverEntry[],\n      // TODO: exclude types from this lint rule: https://github.com/microsoft/fluentui/issues/31286\n      // eslint-disable-next-line no-restricted-globals\n      _observer: ResizeObserver,\n      scrollRef?: React.MutableRefObject<HTMLElement | null>,\n    ) => {\n      if (scrollRef) {\n        handleScrollResize(scrollRef);\n      }\n    },\n    [handleScrollResize],\n  );\n\n  const scrollRef = useMergedRefs(container, useResizeObserverRef_unstable(resizeCallback));\n\n  useIsomorphicLayoutEffect(() => {\n    if (virtualizerContext.contextIndex + virtualizerLength < numItems) {\n      // Avoid re-rendering/re-calculating when the end index has already been reached\n      handleScrollResize(container);\n    }\n  }, [handleScrollResize, numItems, virtualizerContext.contextIndex, virtualizerLength]);\n\n  const updateScrollPosition = React.useCallback(\n    (_scrollPosition: number) => {\n      scrollPosition.current = _scrollPosition;\n      // Check if our vLength's need recalculating\n      handleScrollResize(scrollRef);\n    },\n    [handleScrollResize, scrollRef],\n  );\n\n  return {\n    virtualizerLength,\n    bufferItems: virtualizerBufferItems,\n    bufferSize: virtualizerBufferSize,\n    scrollRef,\n    containerSizeRef,\n    updateScrollPosition,\n  };\n};\n"],"names":["useIsomorphicLayoutEffect","useMergedRefs","React","useResizeObserverRef_unstable","useFluent_unstable","useFluent","useDynamicVirtualizerMeasure","virtualizerProps","defaultItemSize","direction","numItems","getItemSize","bufferItems","bufferSize","virtualizerContext","state","setState","useState","virtualizerLength","virtualizerBufferItems","virtualizerBufferSize","containerSizeRef","useRef","scrollPosition","targetDocument","container","handleScrollResize","useCallback","scrollRef","current","body","getBoundingClientRect","height","width","defaultView","innerHeight","innerWidth","indexSizer","i","length","startIndex","contextIndex","sizeToBeat","iItemSize","childProgressiveSizes","currentScrollPos","currentItemPos","variance","newBufferItems","Math","max","ceil","newBufferSize","totalLength","resizeCallback","_entries","_observer","updateScrollPosition","_scrollPosition"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}