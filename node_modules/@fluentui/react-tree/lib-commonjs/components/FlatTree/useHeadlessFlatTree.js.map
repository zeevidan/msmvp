{"version":3,"sources":["../src/components/FlatTree/useHeadlessFlatTree.ts"],"sourcesContent":["import { useEventCallback, useMergedRefs } from '@fluentui/react-utilities';\nimport * as React from 'react';\nimport { HeadlessTreeItem, HeadlessTreeItemProps, createHeadlessTree } from '../../utils/createHeadlessTree';\nimport { treeDataTypes } from '../../utils/tokens';\nimport { useFlatTreeNavigation } from '../../hooks/useFlatTreeNavigation';\nimport { createNextOpenItems, useControllableOpenItems } from '../../hooks/useControllableOpenItems';\nimport type { TreeItemValue } from '../../TreeItem';\nimport { dataTreeItemValueAttrName } from '../../utils/getTreeItemValueFromElement';\nimport { ImmutableSet } from '../../utils/ImmutableSet';\nimport { createNextFlatCheckedItems, useFlatControllableCheckedItems } from './useFlatControllableCheckedItems';\nimport { FlatTreeProps } from './FlatTree.types';\nimport {\n  TreeCheckedChangeData,\n  TreeCheckedChangeEvent,\n  TreeNavigationData_unstable,\n  TreeOpenChangeData,\n  TreeOpenChangeEvent,\n  TreeProps,\n} from '../Tree/Tree.types';\nimport { ImmutableMap } from '../../utils/ImmutableMap';\n\nexport type HeadlessFlatTreeItemProps = HeadlessTreeItemProps;\nexport type HeadlessFlatTreeItem<Props extends HeadlessFlatTreeItemProps> = HeadlessTreeItem<Props>;\n\n/**\n * FlatTree API to manage all required mechanisms to convert a list of items into renderable TreeItems\n * in multiple scenarios including virtualization.\n *\n * !!A flat tree is an unofficial spec for tree!!\n *\n * It should be used on cases where more complex interactions with a Tree is required.\n *\n * On simple scenarios it is advised to simply use a nested structure instead.\n */\nexport type HeadlessFlatTree<Props extends HeadlessFlatTreeItemProps> = {\n  /**\n   * returns the properties required for the Tree component to work properly.\n   * That includes:\n   * `openItems`, `onOpenChange`, `onNavigation_unstable` and `ref`\n   */\n  getTreeProps(): Required<\n    Pick<FlatTreeProps, 'openItems' | 'onOpenChange' | 'onNavigation' | 'checkedItems' | 'onCheckedChange'>\n  > & {\n    ref: React.Ref<HTMLDivElement>;\n    openItems: ImmutableSet<TreeItemValue>;\n  };\n  /**\n   * internal method used to react to an `onNavigation` event.\n   * This method ensures proper navigation on keyboard and mouse interaction.\n   * In case of virtualization it might be required to cancel default provided `onNavigation`\n   * event and then call this method manually.\n   *\n   * @example\n   * ```ts\n   * // react-window\n   * const handleNavigation = (event, data) => {\n   *   event.preventDefault();\n   *   const nextItem = tree.getNextNavigableItem(data);\n   *   // scroll to item using virtualization scroll mechanism\n   *   if (nextItem && tree.getElementFromItem(nextItem)) {\n   *     listRef.current.scrollToItem(nextItem.index);\n   *   }\n   *   // wait for scrolling to happen and then invoke navigate method\n   *   requestAnimationFrame(() => {\n   *     tree.navigate(data);\n   *   });\n   * };\n   *```\n   */\n  navigate(data: TreeNavigationData_unstable): void;\n  /**\n   * returns next item to be focused on a navigation.\n   * This method is provided to decouple the element that needs to be focused from\n   *  the action of focusing it itself.\n   *\n   * On the case of TypeAhead navigation this method returns the current item.\n   */\n  getNextNavigableItem(\n    visibleItems: HeadlessTreeItem<Props>[],\n    data: TreeNavigationData_unstable,\n  ): HeadlessTreeItem<Props> | undefined;\n  /**\n   * similar to getElementById but for FlatTreeItems\n   */\n  getElementFromItem(item: HeadlessTreeItem<Props>): HTMLElement | null;\n  /**\n   * an iterable containing all visually available flat tree items\n   */\n  items(): IterableIterator<HeadlessTreeItem<Props>>;\n};\n\nexport type HeadlessFlatTreeOptions = Pick<\n  FlatTreeProps,\n  'onOpenChange' | 'onNavigation' | 'selectionMode' | 'onCheckedChange'\n> &\n  Pick<TreeProps, 'defaultOpenItems' | 'openItems' | 'checkedItems'> & {\n    defaultCheckedItems?: TreeProps['checkedItems'];\n  };\n\n/**\n * @internal\n */\ntype HeadlessFlatTreeReturn<Props extends HeadlessFlatTreeItemProps> = HeadlessFlatTree<Props> & {\n  getItem(value: TreeItemValue): HeadlessTreeItem<Props> | undefined;\n};\n\n/**\n * this hook provides FlatTree API to manage all required mechanisms to convert a list of items into renderable TreeItems\n * in multiple scenarios including virtualization.\n *\n * !!A flat tree is an unofficial spec for tree!!\n *\n * It should be used on cases where more complex interactions with a Tree is required.\n * On simple scenarios it is advised to simply use a nested structure instead.\n *\n * @param props - a list of tree items\n * @param options - in case control over the internal openItems is required\n */\nexport function useHeadlessFlatTree_unstable<Props extends HeadlessTreeItemProps>(\n  props: Props[],\n  options: HeadlessFlatTreeOptions = {},\n): HeadlessFlatTreeReturn<Props> {\n  'use no memo';\n\n  const headlessTree = React.useMemo(() => createHeadlessTree(props), [props]);\n  const [openItems, setOpenItems] = useControllableOpenItems(options);\n  const [checkedItems, setCheckedItems] = useFlatControllableCheckedItems(options, headlessTree);\n  const navigation = useFlatTreeNavigation();\n\n  const treeRef = React.useRef<HTMLDivElement>(null);\n  const handleOpenChange = useEventCallback((event: TreeOpenChangeEvent, data: TreeOpenChangeData) => {\n    const nextOpenItems = createNextOpenItems(data, openItems);\n    options.onOpenChange?.(event, {\n      ...data,\n      openItems: ImmutableSet.dangerouslyGetInternalSet(nextOpenItems),\n    });\n    setOpenItems(nextOpenItems);\n  });\n\n  const handleCheckedChange = useEventCallback((event: TreeCheckedChangeEvent, data: TreeCheckedChangeData) => {\n    const nextCheckedItems = createNextFlatCheckedItems(data, checkedItems, headlessTree);\n    options.onCheckedChange?.(event, {\n      ...data,\n      checkedItems: ImmutableMap.dangerouslyGetInternalMap(nextCheckedItems),\n    });\n    setCheckedItems(nextCheckedItems);\n  });\n\n  const getNextNavigableItem = useEventCallback(\n    (visibleItems: HeadlessTreeItem<Props>[], data: TreeNavigationData_unstable) => {\n      const item = headlessTree.get(data.value);\n      if (item) {\n        switch (data.type) {\n          case treeDataTypes.TypeAhead:\n            return item;\n          case treeDataTypes.ArrowLeft:\n            return headlessTree.get(item.parentValue!);\n          case treeDataTypes.ArrowRight:\n            return visibleItems[item.index + 1];\n          case treeDataTypes.End:\n            return visibleItems[visibleItems.length - 1];\n          case treeDataTypes.Home:\n            return visibleItems[0];\n          case treeDataTypes.ArrowDown:\n            return visibleItems[item.index + 1];\n          case treeDataTypes.ArrowUp:\n            return visibleItems[item.index - 1];\n        }\n      }\n    },\n  );\n\n  const getElementFromItem = React.useCallback((item: HeadlessTreeItem<Props>) => {\n    return treeRef.current?.querySelector(`[${dataTreeItemValueAttrName}=\"${item.value}\"]`) as HTMLElement | null;\n  }, []);\n\n  const ref = useMergedRefs<HTMLDivElement>(treeRef, navigation.rootRef);\n\n  const getTreeProps = React.useCallback(\n    () => ({\n      ref,\n      openItems,\n      selectionMode: options.selectionMode,\n      checkedItems,\n      onOpenChange: handleOpenChange,\n      onCheckedChange: handleCheckedChange,\n      onNavigation: options.onNavigation ?? noop,\n    }),\n    // ref, handleOpenChange - useEventCallback, handleCheckedChange - useEventCallback\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [openItems, checkedItems, options.selectionMode, options.onNavigation],\n  );\n\n  const items = React.useCallback(() => headlessTree.visibleItems(openItems), [openItems, headlessTree]);\n\n  const getItem = React.useCallback((value: TreeItemValue) => headlessTree.get(value), [headlessTree]);\n\n  return React.useMemo<HeadlessFlatTreeReturn<Props>>(\n    () => ({\n      navigate: navigation.navigate,\n      getTreeProps,\n      getNextNavigableItem,\n      getElementFromItem,\n      items,\n      getItem,\n    }),\n    [navigation.navigate, getTreeProps, getNextNavigableItem, getElementFromItem, items, getItem],\n  );\n}\n\n/** @internal */\nfunction noop() {\n  /* noop */\n}\n"],"names":["useHeadlessFlatTree_unstable","props","options","headlessTree","React","useMemo","createHeadlessTree","openItems","setOpenItems","useControllableOpenItems","checkedItems","setCheckedItems","useFlatControllableCheckedItems","navigation","useFlatTreeNavigation","treeRef","useRef","handleOpenChange","useEventCallback","event","data","nextOpenItems","createNextOpenItems","onOpenChange","ImmutableSet","dangerouslyGetInternalSet","handleCheckedChange","nextCheckedItems","createNextFlatCheckedItems","onCheckedChange","ImmutableMap","dangerouslyGetInternalMap","getNextNavigableItem","visibleItems","item","get","value","type","treeDataTypes","TypeAhead","ArrowLeft","parentValue","ArrowRight","index","End","length","Home","ArrowDown","ArrowUp","getElementFromItem","useCallback","current","querySelector","dataTreeItemValueAttrName","ref","useMergedRefs","rootRef","getTreeProps","selectionMode","onNavigation","noop","items","getItem","navigate"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}