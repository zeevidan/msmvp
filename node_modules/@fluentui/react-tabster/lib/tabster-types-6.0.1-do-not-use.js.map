{"version":3,"sources":["../src/tabster-types-6.0.1-do-not-use.ts"],"sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * WARNING! ATTENTION! WARNING! ATTENTION! WARNING! ATTENTION!\n * WARNING! ATTENTION! WARNING! ATTENTION! WARNING! ATTENTION!\n *\n * Do not use anything from this file. It is a snapshot of the older Tabster typings exposed by a mistake.\n * The exposed typings should have been removed, but we don't do it in minor versions to avoid breaking changes.\n * Everything reexported from this file as react-tabster/TabsterTypes is marked as deprecated and shouldn't\n * be used anywhre.\n *\n * WARNING! ATTENTION! WARNING! ATTENTION! WARNING! ATTENTION!\n * WARNING! ATTENTION! WARNING! ATTENTION! WARNING! ATTENTION!\n */\n\nexport const TabsterAttributeName = 'data-tabster';\nexport const TabsterDummyInputAttributeName = 'data-tabster-dummy';\nexport const DeloserEventName = 'tabster:deloser';\nexport const ModalizerActiveEventName = 'tabster:modalizer:active';\nexport const ModalizerInactiveEventName = 'tabster:modalizer:inactive';\nexport const ModalizerFocusInEventName = 'tabster:modalizer:focusin';\nexport const ModalizerFocusOutEventName = 'tabster:modalizer:focusout';\nexport const ModalizerBeforeFocusOutEventName = 'tabster:modalizer:beforefocusout';\nexport const MoverEventName = 'tabster:mover';\nexport const FocusInEventName = 'tabster:focusin';\nexport const FocusOutEventName = 'tabster:focusout';\n\n// Event to be triggered when Tabster wants to move focus as the result of\n// keyboard event. This allows to preventDefault() if you want to have\n// some custom logic.\nexport const MoveFocusEventName = 'tabster:movefocus';\n\n// Event that can be triggered by the application to programmatically move\n// focus inside Mover.\nexport const MoverMoveFocusEventName = 'tabster:mover:movefocus';\n// Event that can be triggered by the application to programmatically enter\n// or escape Groupper.\nexport const GroupperMoveFocusEventName = 'tabster:groupper:movefocus';\n\nexport const FocusableSelector = [\n  'a[href]',\n  'button:not([disabled])',\n  'input:not([disabled])',\n  'select:not([disabled])',\n  'textarea:not([disabled])',\n  '*[tabindex]',\n  '*[contenteditable]',\n].join(', ');\n\n// Trigger move focus event on a Mover element.\nexport type MoverMoveFocusEvent = CustomEvent<{ key: MoverKey } | undefined>;\n\nexport interface GroupperMoveFocusActions {\n  Enter: 1;\n  Escape: 2;\n}\nexport type GroupperMoveFocusAction = GroupperMoveFocusActions[keyof GroupperMoveFocusActions];\nexport const GroupperMoveFocusActions: GroupperMoveFocusActions = {\n  Enter: 1,\n  Escape: 2,\n};\n\n// Enter or escape Groupper. Enter when `enter` is true, escape when `enter` is false.\nexport type GroupperMoveFocusEvent = CustomEvent<{ action: GroupperMoveFocusAction } | undefined>;\n\nexport type TabsterEventWithDetails<D> = CustomEvent<D | undefined>;\n\nexport interface TabsterMoveFocusEventDetails {\n  by: 'mover' | 'groupper' | 'modalizer' | 'root';\n  owner: HTMLElement; // Mover, Groupper, Modalizer or Root, the initiator.\n  next: HTMLElement | null; // Next element to focus or null if Tabster wants to go outside of Root (i.e. to the address bar of the browser).\n  relatedEvent?: KeyboardEvent; // The original keyboard event that triggered the move.\n}\n\nexport type TabsterMoveFocusEvent = TabsterEventWithDetails<TabsterMoveFocusEventDetails>;\n\nexport interface TabsterDOMAttribute {\n  [TabsterAttributeName]: string | undefined;\n}\n\nexport interface TabsterCoreProps {\n  autoRoot?: RootProps;\n  /**\n   * Allows all tab key presses under the tabster root to be controlled by tabster\n   * @default true\n   */\n  controlTab?: boolean;\n  /**\n   * When controlTab is false, Root doesn't have dummy inputs by default.\n   * This option allows to enable dummy inputs on Root.\n   */\n  rootDummyInputs?: boolean;\n  /**\n   * A callback that will be called for the uncontrolled areas when Tabster wants\n   * to know is the uncontrolled element wants complete control (for example it\n   * is trapping focus) and Tabster should not interfere with handling Tab.\n   * If the callback returns undefined, then the default behaviour is to return\n   * the uncontrolled.completely value from the element. If the callback returns\n   * non-undefined value, the callback's value will dominate the element's\n   * uncontrolled.completely value.\n   */\n  checkUncontrolledCompletely?: (\n    element: HTMLElement,\n    completely: boolean, // A uncontrolled.completely value from the element.\n  ) => boolean | undefined;\n  /**\n   * @deprecated use checkUncontrolledCompletely.\n   */\n  checkUncontrolledTrappingFocus?: (element: HTMLElement) => boolean;\n  /**\n   * Custom getter for parent elements. Defaults to the default .parentElement call\n   * Currently only used to detect tabster contexts\n   */\n  getParent?(el: Node): Node | null;\n  /**\n   * Ability to redefine all DOM API calls used by Tabster. For example, for\n   * ShadowDOM support.\n   */\n  DOMAPI?: Partial<DOMAPI>;\n}\n\nexport interface DOMAPI {\n  // TODO: exclude types from this lint rule: https://github.com/microsoft/fluentui/issues/31286\n\n  createMutationObserver: (callback: MutationCallback) => MutationObserver;\n  createTreeWalker(doc: Document, root: Node, whatToShow?: number, filter?: NodeFilter | null): TreeWalker;\n  getParentNode(node: Node | null | undefined): ParentNode | null;\n  getParentElement(element: HTMLElement | null | undefined): HTMLElement | null;\n  nodeContains(parent: Node | null | undefined, child: Node | null | undefined): boolean;\n  getActiveElement(doc: Document): Element | null;\n  querySelector(element: ParentNode, selector: string): Element | null;\n  querySelectorAll(element: ParentNode, selector: string): Element[];\n  getElementById(doc: Document, id: string): HTMLElement | null;\n  getFirstChild(node: Node | null | undefined): ChildNode | null;\n  getLastChild(node: Node | null | undefined): ChildNode | null;\n  getNextSibling(node: Node | null | undefined): ChildNode | null;\n  getPreviousSibling(node: Node | null | undefined): ChildNode | null;\n  getFirstElementChild(element: Element | null | undefined): Element | null;\n  getLastElementChild(element: Element | null | undefined): Element | null;\n  getNextElementSibling(element: Element | null | undefined): Element | null;\n  getPreviousElementSibling(element: Element | null | undefined): Element | null;\n  appendChild(parent: Node, child: Node): Node;\n  insertBefore(parent: Node, child: Node, referenceChild: Node | null): Node;\n  getSelection(ref: Node): Selection | null;\n}\n\nexport type GetTabster = () => TabsterCore;\nexport type GetWindow = () => Window;\n\nexport type SubscribableCallback<A, B = undefined> = (val: A, details: B) => void;\n\nexport interface Disposable {\n  /** @internal */\n  dispose(): void;\n}\n\nexport interface Subscribable<A, B = undefined> {\n  subscribe(callback: SubscribableCallback<A, B>): void;\n  /** @internal */\n  subscribeFirst(callback: SubscribableCallback<A, B>): void;\n  unsubscribe(callback: SubscribableCallback<A, B>): void;\n}\n\nexport interface KeyboardNavigationState extends Subscribable<boolean>, Disposable {\n  isNavigatingWithKeyboard(): boolean;\n  setNavigatingWithKeyboard(isNavigatingWithKeyboard: boolean): void;\n}\n\nexport interface FocusedElementDetails {\n  relatedTarget?: HTMLElement;\n  isFocusedProgrammatically?: boolean;\n  modalizerId?: string;\n}\n\nexport interface FocusedElementState extends Subscribable<HTMLElement | undefined, FocusedElementDetails>, Disposable {\n  getFocusedElement(): HTMLElement | undefined;\n  getLastFocusedElement(): HTMLElement | undefined;\n  focus(element: HTMLElement, noFocusedProgrammaticallyFlag?: boolean, noAccessibleCheck?: boolean): boolean;\n  focusDefault(container: HTMLElement): boolean;\n  /** @internal */\n  getFirstOrLastTabbable(\n    isFirst: boolean,\n    props: Pick<FindFocusableProps, 'container' | 'ignoreAccessibility'>,\n  ): HTMLElement | undefined;\n  focusFirst(props: FindFirstProps): boolean;\n  focusLast(props: FindFirstProps): boolean;\n  resetFocus(container: HTMLElement): boolean;\n}\n\nexport interface WeakHTMLElement<D = undefined> {\n  get(): HTMLElement | undefined;\n  getData(): D | undefined;\n}\n\nexport interface TabsterPart<P> {\n  readonly id: string;\n  getElement(): HTMLElement | undefined;\n  getProps(): P;\n  setProps(props: P): void;\n}\n\nexport interface TabsterPartWithFindNextTabbable {\n  findNextTabbable(\n    current?: HTMLElement,\n    reference?: HTMLElement,\n    isBackward?: boolean,\n    ignoreAccessibility?: boolean,\n  ): NextTabbable | null;\n}\n\nexport interface TabsterPartWithAcceptElement {\n  acceptElement(element: HTMLElement, state: FocusableAcceptElementState): number | undefined;\n}\n\nexport interface ObservedElementProps {\n  names: string[];\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  details?: any;\n}\n\nexport interface ObservedElementDetails extends ObservedElementProps {\n  accessibility?: ObservedElementAccesibility;\n}\n\nexport interface ObservedElementAccesibilities {\n  Any: 0;\n  Accessible: 1;\n  Focusable: 2;\n}\nexport type ObservedElementAccesibility = ObservedElementAccesibilities[keyof ObservedElementAccesibilities];\nexport const ObservedElementAccesibilities: ObservedElementAccesibilities = {\n  Any: 0,\n  Accessible: 1,\n  Focusable: 2,\n};\n\nexport interface ObservedElementAsyncRequest<T> {\n  result: Promise<T>;\n  cancel(): void;\n}\n\ninterface ObservedElementAPIInternal {\n  /** @internal */\n  onObservedElementUpdate(element: HTMLElement): void;\n}\n\nexport interface ObservedElementAPI\n  extends Subscribable<HTMLElement, ObservedElementDetails>,\n    Disposable,\n    ObservedElementAPIInternal {\n  getElement(observedName: string, accessibility?: ObservedElementAccesibility): HTMLElement | null;\n  waitElement(\n    observedName: string,\n    timeout: number,\n    accessibility?: ObservedElementAccesibility,\n  ): ObservedElementAsyncRequest<HTMLElement | null>;\n  requestFocus(observedName: string, timeout: number): ObservedElementAsyncRequest<boolean>;\n}\n\nexport interface CrossOriginElement {\n  readonly uid: string;\n  readonly ownerId: string;\n  readonly id?: string;\n  readonly rootId?: string;\n  readonly observedName?: string;\n  readonly observedDetails?: string;\n  focus(noFocusedProgrammaticallyFlag?: boolean, noAccessibleCheck?: boolean): Promise<boolean>;\n}\n\nexport interface CrossOriginSentTo {\n  [id: string]: true;\n}\n\nexport interface CrossOriginTransactionTypes {\n  Bootstrap: 1;\n  FocusElement: 2;\n  State: 3;\n  GetElement: 4;\n  RestoreFocusInDeloser: 5;\n  Ping: 6;\n}\nexport type CrossOriginTransactionType = CrossOriginTransactionTypes[keyof CrossOriginTransactionTypes];\n\nexport interface CrossOriginTransactionData<I, O> {\n  transaction: string;\n  type: CrossOriginTransactionType;\n  isResponse: boolean;\n  timestamp: number;\n  owner: string;\n  sentto: CrossOriginSentTo;\n  timeout?: number;\n  target?: string;\n  beginData?: I;\n  endData?: O;\n}\n\nexport type CrossOriginTransactionSend = (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  data: CrossOriginTransactionData<any, any>,\n) => void;\n\nexport interface CrossOriginMessage {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  data: CrossOriginTransactionData<any, any>;\n  send: CrossOriginTransactionSend;\n}\n\nexport interface CrossOriginFocusedElementState\n  extends Subscribable<CrossOriginElement | undefined, FocusedElementDetails>,\n    Disposable {\n  focus(\n    element: CrossOriginElement,\n    noFocusedProgrammaticallyFlag?: boolean,\n    noAccessibleCheck?: boolean,\n  ): Promise<boolean>;\n  focusById(\n    elementId: string,\n    rootId?: string,\n    noFocusedProgrammaticallyFlag?: boolean,\n    noAccessibleCheck?: boolean,\n  ): Promise<boolean>;\n  focusByObservedName(\n    observedName: string,\n    timeout?: number,\n    rootId?: string,\n    noFocusedProgrammaticallyFlag?: boolean,\n    noAccessibleCheck?: boolean,\n  ): Promise<boolean>;\n}\n\nexport interface CrossOriginObservedElementState\n  extends Subscribable<CrossOriginElement, ObservedElementProps>,\n    Disposable {\n  getElement(observedName: string, accessibility?: ObservedElementAccesibility): Promise<CrossOriginElement | null>;\n  waitElement(\n    observedName: string,\n    timeout: number,\n    accessibility?: ObservedElementAccesibility,\n  ): Promise<CrossOriginElement | null>;\n  requestFocus(observedName: string, timeout: number): Promise<boolean>;\n}\n\nexport interface CrossOriginAPI {\n  focusedElement: CrossOriginFocusedElementState;\n  observedElement: CrossOriginObservedElementState;\n\n  setup(sendUp?: CrossOriginTransactionSend | null): (msg: CrossOriginMessage) => void;\n  isSetUp(): boolean;\n  dispose(): void;\n}\n\nexport interface OutlineProps {\n  areaClass: string;\n  outlineClass: string;\n  outlineColor: string;\n  outlineWidth: number;\n  zIndex: number;\n}\n\nexport interface OutlinedElementProps {\n  isIgnored?: boolean;\n}\n\nexport interface OutlineAPI extends Disposable {\n  setup(props?: Partial<OutlineProps>): void;\n}\n\nexport interface DeloserElementActions {\n  focusDefault: () => boolean;\n  focusFirst: () => boolean;\n  resetFocus: () => boolean;\n  clearHistory: (preserveExisting?: boolean) => void;\n  setSnapshot: (index: number) => void;\n  isActive: () => boolean;\n}\n\nexport interface RestoreFocusOrders {\n  History: 0;\n  DeloserDefault: 1;\n  RootDefault: 2;\n  DeloserFirst: 3;\n  RootFirst: 4;\n}\nexport type RestoreFocusOrder = RestoreFocusOrders[keyof RestoreFocusOrders];\nexport const RestoreFocusOrders: RestoreFocusOrders = {\n  History: 0,\n  DeloserDefault: 1,\n  RootDefault: 2,\n  DeloserFirst: 3,\n  RootFirst: 4,\n};\n\nexport interface DeloserProps {\n  restoreFocusOrder?: RestoreFocusOrder;\n  noSelectorCheck?: boolean;\n}\n\nexport interface Deloser extends TabsterPart<DeloserProps> {\n  readonly uid: string;\n  dispose(): void;\n  isActive(): boolean;\n  setActive(active: boolean): void;\n  getActions(): DeloserElementActions;\n  setSnapshot(index: number): void;\n  focusFirst(): boolean;\n  unshift(element: HTMLElement): void;\n  focusDefault(): boolean;\n  resetFocus(): boolean;\n  findAvailable(): HTMLElement | null;\n  clearHistory(preserveExisting?: boolean): void;\n  customFocusLostHandler(element: HTMLElement): boolean;\n}\n\nexport type DeloserConstructor = (element: HTMLElement, props: DeloserProps) => Deloser;\n\ninterface DeloserInterfaceInternal {\n  /** @internal */\n  createDeloser(element: HTMLElement, props: DeloserProps): Deloser;\n}\n\nexport interface DeloserAPI extends DeloserInterfaceInternal, Disposable {\n  getActions(element: HTMLElement): DeloserElementActions | undefined;\n  pause(): void;\n  resume(restore?: boolean): void;\n}\n\nexport interface FocusableProps {\n  isDefault?: boolean;\n  isIgnored?: boolean;\n  /**\n   * Do not determine an element's focusability based on aria-disabled.\n   */\n  ignoreAriaDisabled?: boolean;\n  /**\n   * Exclude element (and all subelements) from Mover navigation.\n   */\n  excludeFromMover?: boolean;\n  /**\n   * Prevents tabster from handling the keydown event\n   */\n  ignoreKeydown?: {\n    Tab?: boolean;\n    Escape?: boolean;\n    Enter?: boolean;\n    ArrowUp?: boolean;\n    ArrowDown?: boolean;\n    ArrowLeft?: boolean;\n    ArrowRight?: boolean;\n    PageUp?: boolean;\n    PageDown?: boolean;\n    Home?: boolean;\n    End?: boolean;\n  };\n}\n\nexport interface FocusableAcceptElementState {\n  container: HTMLElement;\n  modalizerUserId?: string;\n  currentCtx?: TabsterContext;\n  from: HTMLElement;\n  fromCtx?: TabsterContext;\n  isBackward?: boolean;\n  found?: boolean;\n  foundElement?: HTMLElement;\n  foundBackward?: HTMLElement;\n  rejectElementsFrom?: HTMLElement;\n  uncontrolled?: HTMLElement;\n  acceptCondition: (el: HTMLElement) => boolean;\n  hasCustomCondition?: boolean;\n  includeProgrammaticallyFocusable?: boolean;\n  ignoreAccessibility?: boolean;\n  cachedGrouppers: {\n    [id: string]: {\n      isActive: boolean | undefined;\n      first?: HTMLElement | null;\n    };\n  };\n  isFindAll?: boolean;\n  /**\n   * A flag that indicates that some focusable elements were skipped\n   * during the search and the found element is not the one the browser\n   * would normally focus if the user pressed Tab.\n   */\n  skippedFocusable?: boolean;\n}\n\nexport interface FindFocusableProps {\n  /**\n   * The container used for the search.\n   */\n  container: HTMLElement;\n  /**\n   * The elemet to start from.\n   */\n  currentElement?: HTMLElement;\n  /**\n   * See `referenceElement` of GetTabsterContextOptions for description.\n   */\n  referenceElement?: HTMLElement;\n  /**\n   * Includes elements that can be focused programmatically.\n   */\n  includeProgrammaticallyFocusable?: boolean;\n  /**\n   * Ignore accessibility check.\n   */\n  ignoreAccessibility?: boolean;\n  /**\n   * Take active modalizer into account when searching for elements\n   * (the elements out of active modalizer will not be returned).\n   */\n  useActiveModalizer?: boolean;\n  /**\n   * Search withing the specified modality, null for everything outside of modalizers, string within\n   * a specific id, undefined for search within the current application state.\n   */\n  modalizerId?: string | null;\n  /**\n   * If true, find previous element instead of the next one.\n   */\n  isBackward?: boolean;\n  /**\n   * @param el - element visited.\n   * @returns if an element should be accepted.\n   */\n  acceptCondition?(el: HTMLElement): boolean;\n  /**\n   * A callback that will be called for every focusable element found during findAll().\n   * If false is returned from this callback, the search will stop.\n   */\n  onElement?: FindElementCallback;\n}\n\nexport interface FindFocusableOutputProps {\n  /**\n   * An output parameter. Will be true after the findNext/findPrev() call if some focusable\n   * elements were skipped during the search and the result element not immediately next\n   * focusable after the currentElement.\n   */\n  outOfDOMOrder?: boolean;\n  /**\n   * An output parameter. Will be true if the found element is uncontrolled.\n   */\n  uncontrolled?: HTMLElement | null;\n}\n\nexport type FindFirstProps = Pick<\n  FindFocusableProps,\n  'container' | 'modalizerId' | 'includeProgrammaticallyFocusable' | 'useActiveModalizer' | 'ignoreAccessibility'\n>;\n\nexport type FindNextProps = Pick<\n  FindFocusableProps,\n  | 'currentElement'\n  | 'referenceElement'\n  | 'container'\n  | 'modalizerId'\n  | 'includeProgrammaticallyFocusable'\n  | 'useActiveModalizer'\n  | 'ignoreAccessibility'\n>;\n\nexport type FindDefaultProps = Pick<\n  FindFocusableProps,\n  'container' | 'modalizerId' | 'includeProgrammaticallyFocusable' | 'useActiveModalizer' | 'ignoreAccessibility'\n>;\n\nexport type FindAllProps = Pick<\n  FindFocusableProps,\n  | 'container'\n  | 'modalizerId'\n  | 'currentElement'\n  | 'isBackward'\n  | 'includeProgrammaticallyFocusable'\n  | 'useActiveModalizer'\n  | 'acceptCondition'\n  | 'ignoreAccessibility'\n  | 'onElement'\n>;\n\n/**\n * A callback that is called for every found element during search. Returning false stops search.\n */\nexport type FindElementCallback = (element: HTMLElement) => boolean;\n\nexport interface FocusableAPI extends Disposable {\n  getProps(element: HTMLElement): FocusableProps;\n\n  isFocusable(\n    element: HTMLElement,\n    includeProgrammaticallyFocusable?: boolean,\n    noVisibleCheck?: boolean,\n    noAccessibleCheck?: boolean,\n  ): boolean;\n  isVisible(element: HTMLElement): boolean;\n  isAccessible(element: HTMLElement): boolean;\n  // find* return null when there is no element and undefined when there is an uncontrolled area.\n  findFirst(options: FindFirstProps, out?: FindFocusableOutputProps): HTMLElement | null | undefined;\n  findLast(options: FindFirstProps, out?: FindFocusableOutputProps): HTMLElement | null | undefined;\n  findNext(options: FindNextProps, out?: FindFocusableOutputProps): HTMLElement | null | undefined;\n  findPrev(options: FindNextProps, out?: FindFocusableOutputProps): HTMLElement | null | undefined;\n  findDefault(options: FindDefaultProps, out?: FindFocusableOutputProps): HTMLElement | null;\n  /**\n   * @returns All focusables in a given context that satisfy an given condition\n   */\n  findAll(options: FindAllProps): HTMLElement[];\n  findElement(options: FindFocusableProps, out?: FindFocusableOutputProps): HTMLElement | null | undefined;\n}\n\nexport interface DummyInputManager {\n  moveOut: (backwards: boolean) => void;\n  moveOutWithDefaultAction: (backwards: boolean, relatedEvent: KeyboardEvent) => void;\n}\n\nexport interface Visibilities {\n  Invisible: 0;\n  PartiallyVisible: 1;\n  Visible: 2;\n}\nexport const Visibilities: Visibilities = {\n  Invisible: 0,\n  PartiallyVisible: 1,\n  Visible: 2,\n};\nexport type Visibility = Visibilities[keyof Visibilities];\n\nexport interface MoverElementState {\n  isCurrent: boolean | undefined; // Tri-state bool. Undefined when there is no current in the container.\n  visibility: Visibility;\n}\n\nexport interface MoverDirections {\n  Both: 0; // Default, both left/up keys move to the previous, right/down move to the next.\n  Vertical: 1; // Only up/down arrows move to the next/previous.\n  Horizontal: 2; // Only left/right arrows move to the next/previous.\n  Grid: 3; // Two-dimentional movement depending on the visual placement.\n  GridLinear: 4; // Two-dimentional movement depending on the visual placement. Allows linear movement.\n}\n\nexport const RestorerTypes = {\n  Source: 0,\n  Target: 1,\n} as const;\n\nexport type RestorerType = (typeof RestorerTypes)[keyof typeof RestorerTypes];\n\nexport const MoverDirections: MoverDirections = {\n  Both: 0,\n  Vertical: 1,\n  Horizontal: 2,\n  Grid: 3,\n  GridLinear: 4,\n};\nexport type MoverDirection = MoverDirections[keyof MoverDirections];\n\nexport type NextTabbable = {\n  element: HTMLElement | null | undefined;\n  uncontrolled?: HTMLElement | null;\n  outOfDOMOrder?: boolean;\n};\n\nexport interface MoverProps {\n  direction?: MoverDirection;\n  memorizeCurrent?: boolean;\n  tabbable?: boolean;\n  /**\n   * Whether to allow cyclic navigation in the mover\n   * Can only be applied if navigationType is MoverKeys.Arrows\n   *\n   * @defaultValue false\n   */\n  cyclic?: boolean;\n  /**\n   * In case we need a rich state of the elements inside a Mover,\n   * we can track it. It takes extra resourses and might affect\n   * performance when a Mover has many elements inside, so make sure\n   * you use this prop when it is really needed.\n   */\n  trackState?: boolean;\n  /**\n   * When set to Visibility.Visible or Visibility.PartiallyVisible,\n   * uses the visibility part of the trackState prop to be able to\n   * go to first/last visible element (instead of first/last focusable\n   * element in DOM) when tabbing from outside of the mover.\n   */\n  visibilityAware?: Visibility;\n  /**\n   * When true, Mover will try to locate a focusable with Focusable.isDefault\n   * property as a prioritized element to focus. True by default.\n   */\n  hasDefault?: boolean;\n  /**\n   * A value between 0 and 1 that specifies the tolerance allowed\n   * when testing for visibility.\n   *\n   * @example\n   * an element of height 100px has 10px that are above the viewport\n   * hidden by scroll. This element is a valid visible element to focus.\n   *\n   * @default 0.8\n   */\n  visibilityTolerance?: number;\n}\n\nexport type MoverEvent = TabsterEventWithDetails<MoverElementState>;\n\nexport interface Mover extends TabsterPart<MoverProps>, TabsterPartWithFindNextTabbable, TabsterPartWithAcceptElement {\n  readonly id: string;\n  readonly dummyManager: DummyInputManager | undefined;\n  readonly visibilityTolerance: NonNullable<MoverProps['visibilityTolerance']>;\n  dispose(): void;\n  setCurrent(element: HTMLElement | undefined): void;\n  getCurrent(): HTMLElement | null;\n  getState(element: HTMLElement): MoverElementState | undefined;\n}\n\nexport type MoverConstructor = (tabster: TabsterCore, element: HTMLElement, props: MoverProps) => Mover;\n\ninterface MoverAPIInternal {\n  /** @internal */\n  createMover(element: HTMLElement, props: MoverProps, sys: SysProps | undefined): Mover;\n}\n\nexport interface MoverKeys {\n  ArrowUp: 1;\n  ArrowDown: 2;\n  ArrowLeft: 3;\n  ArrowRight: 4;\n  PageUp: 5;\n  PageDown: 6;\n  Home: 7;\n  End: 8;\n}\nexport type MoverKey = MoverKeys[keyof MoverKeys];\nexport const MoverKeys: MoverKeys = {\n  ArrowUp: 1,\n  ArrowDown: 2,\n  ArrowLeft: 3,\n  ArrowRight: 4,\n  PageUp: 5,\n  PageDown: 6,\n  Home: 7,\n  End: 8,\n};\n\nexport interface MoverAPI extends MoverAPIInternal, Disposable {\n  /** @internal (will likely be exposed once the API is fully stable) */\n  moveFocus(fromElement: HTMLElement, key: MoverKey): HTMLElement | null;\n}\n\nexport interface GroupperTabbabilities {\n  Unlimited: 0;\n  Limited: 1; // The tabbability is limited to the container and explicit Enter is needed to go inside.\n  LimitedTrapFocus: 2; // The focus is limited as above, plus trapped when inside.\n}\nexport const GroupperTabbabilities: GroupperTabbabilities = {\n  Unlimited: 0,\n  Limited: 1,\n  LimitedTrapFocus: 2,\n};\nexport type GroupperTabbability = GroupperTabbabilities[keyof GroupperTabbabilities];\n\nexport interface GroupperProps {\n  tabbability?: GroupperTabbability;\n  delegated?: boolean; // This allows to tweak the groupper behaviour for the cases when\n  // the groupper container is not focusable and groupper has Limited or LimitedTrapFocus\n  // tabbability. By default, the groupper will automatically become active once the focus\n  // goes to first focusable element inside the groupper during tabbing. When true, the\n  // groupper will become active only after Enter is pressed on first focusable element\n  // inside the groupper.\n}\n\nexport interface Groupper\n  extends TabsterPart<GroupperProps>,\n    TabsterPartWithFindNextTabbable,\n    TabsterPartWithAcceptElement {\n  readonly id: string;\n  readonly dummyManager: DummyInputManager | undefined;\n  dispose(): void;\n  makeTabbable(isUnlimited: boolean): void;\n  isActive(noIfFirstIsFocused?: boolean): boolean | undefined; // Tri-state boolean, undefined when parent is not active, false when parent is active.\n  setFirst(element: HTMLElement | undefined): void;\n  getFirst(orContainer: boolean): HTMLElement | undefined;\n}\n\nexport type GroupperConstructor = (tabster: TabsterCore, element: HTMLElement, props: GroupperProps) => Groupper;\n\nexport interface GroupperAPIInternal {\n  /** @internal */\n  createGroupper(element: HTMLElement, props: GroupperProps, sys: SysProps | undefined): Groupper;\n  /** @internal */\n  handleKeyPress(element: HTMLElement, event: KeyboardEvent, fromModalizer?: boolean): void;\n}\n\nexport interface GroupperAPI extends GroupperAPIInternal, Disposable {\n  /** @internal (will likely be exposed once the API is fully stable) */\n  moveFocus(element: HTMLElement, action: GroupperMoveFocusAction): HTMLElement | null;\n}\n\nexport interface GroupperAPIInternal {\n  forgetCurrentGrouppers(): void;\n}\n\nexport interface ModalizerProps {\n  id: string;\n  isOthersAccessible?: boolean;\n  isAlwaysAccessible?: boolean;\n  isNoFocusFirst?: boolean;\n  isNoFocusDefault?: boolean;\n  /** A focus trap variant, keeps focus inside the modal when tabbing */\n  isTrapped?: boolean;\n}\n\nexport type ModalizerEventName =\n  | typeof ModalizerActiveEventName\n  | typeof ModalizerInactiveEventName\n  | typeof ModalizerBeforeFocusOutEventName\n  | typeof ModalizerFocusInEventName\n  | typeof ModalizerFocusOutEventName;\n\nexport type ModalizerEventDetails = {\n  id: string;\n  element: HTMLElement;\n  eventName: ModalizerEventName;\n};\n\nexport type ModalizerEvent = TabsterEventWithDetails<ModalizerEventDetails>;\n\nexport interface Modalizer extends TabsterPart<ModalizerProps>, TabsterPartWithFindNextTabbable {\n  readonly userId: string;\n  readonly dummyManager: DummyInputManager | undefined;\n  /**\n   * @returns - Whether the element is inside the modalizer\n   */\n  contains(element: HTMLElement): boolean;\n  dispose(): void;\n  isActive(): boolean;\n  makeActive(isActive: boolean): void;\n  focused(noIncrement?: boolean): number;\n  triggerFocusEvent(eventName: ModalizerEventName, allElements: boolean): boolean;\n}\n\nexport type ModalizerConstructor = (tabster: TabsterCore, element: HTMLElement, props: ModalizerProps) => Modalizer;\n\nexport interface RootProps {\n  restoreFocusOrder?: RestoreFocusOrder;\n}\n\nexport interface Root extends TabsterPart<RootProps> {\n  /**@internal*/\n  addDummyInputs(): void;\n\n  readonly uid: string;\n  dispose(): void;\n  moveOutWithDefaultAction(backwards: boolean, relatedEvent: KeyboardEvent): void;\n}\n\nexport type RootConstructor = (tabster: TabsterCore, element: HTMLElement, props: RootProps) => Root;\n\nexport interface SysDummyInputsPositions {\n  Auto: 0; // Tabster will place dummy inputs depending on the container tag name and on the default behaviour.\n  Inside: 1; // Tabster will always place dummy inputs inside the container.\n  Outside: 2; // Tabster will always place dummy inputs outside of the container.\n}\nexport const SysDummyInputsPositions: SysDummyInputsPositions = {\n  Auto: 0,\n  Inside: 1,\n  Outside: 2,\n};\nexport type SysDummyInputsPosition = SysDummyInputsPositions[keyof SysDummyInputsPositions];\n/**\n * Ability to fine-tune Tabster internal behaviour in rare cases of need.\n * Normally, should not be used. A deep understanding of the intention and the effect\n * is required.\n */\nexport interface SysProps {\n  /**\n   * Force dummy input position outside or inside of the element.\n   * By default (when undefined), the position is determined dynamically\n   * (for example inside for <li> elements and outside for <table> elements,\n   * plus a default Groupper/Mover/Modalizer implementation position).\n   * Setting to true will force the dummy inputs to be always outside of the element,\n   * setting to false will force the dummy inputs to be always inside.\n   */\n  dummyInputsPosition?: SysDummyInputsPosition;\n}\n\nexport interface GetTabsterContextOptions {\n  /**\n   * Should visit **all** element ancestors to verify if `dir='rtl'` is set\n   */\n  checkRtl?: boolean;\n  /**\n   * The element to start computing the context from. Useful when dealing\n   * with nested structures. For example, if we have an element inside a groupper\n   * inside another groupper, the `groupper` prop in this element's contexts will\n   * be the inner groupper, but when we pass the inner groupper's parent element\n   * as `referenceElement`, the context groupper will be the outer one. Having\n   * this option simplifies searching for the next tabbable element in the\n   * environment of nested movers and grouppers.\n   */\n  referenceElement?: HTMLElement;\n}\n\nexport type TabsterContextMoverGroupper = { isMover: true; mover: Mover } | { isMover: false; groupper: Groupper };\n\nexport interface TabsterContext {\n  root: Root;\n  modalizer?: Modalizer;\n  groupper?: Groupper;\n  mover?: Mover;\n  groupperBeforeMover?: boolean;\n  modalizerInGroupper?: Groupper;\n  /**\n   * Whether `dir='rtl'` is set on an ancestor\n   */\n  rtl?: boolean;\n  excludedFromMover?: boolean;\n  uncontrolled?: HTMLElement | null;\n  ignoreKeydown: (e: KeyboardEvent) => boolean;\n}\n\nexport interface RootFocusEventDetails {\n  element: HTMLElement;\n}\n\ninterface RootAPIInternal {\n  /**@internal*/\n  createRoot(element: HTMLElement, props: RootProps, sys: SysProps | undefined): Root;\n  /**@internal*/\n  onRoot(root: Root, removed?: boolean): void;\n  /**@internal*/\n  addDummyInputs(): void;\n}\n\nexport interface RootAPI extends Disposable, RootAPIInternal {\n  eventTarget: EventTarget;\n}\n\nexport interface UncontrolledAPI {\n  isUncontrolledCompletely(element: HTMLElement, completely: boolean): boolean;\n}\n\ninterface ModalizerAPIInternal extends TabsterPartWithAcceptElement {\n  /** @internal */\n  activeId: string | undefined; // currently active Modalizer user id.\n  /** @internal */\n  currentIsOthersAccessible: boolean | undefined; // isOthersAccessible value of the currently active Modalizer.\n  /** @internal */\n  activeElements: WeakHTMLElement<HTMLElement>[];\n  /** @internal */\n  createModalizer(element: HTMLElement, props: ModalizerProps, sys: SysProps | undefined): Modalizer;\n  /**\n   * Sets active modalizers.\n   * When active, everything outside of the modalizers with the specific user\n   * defined id gets `aria-hidden`.\n   *\n   * @param userId - user defined identifier or undefined (if nothing is modal).\n   */\n  /** @internal */\n  setActive(modalizer: Modalizer | undefined): void;\n  /** @internal */\n  hiddenUpdate(): void;\n  /** @internal */\n  isAugmented(element: HTMLElement): boolean;\n}\n\nexport interface ModalizerAPI extends ModalizerAPIInternal, Disposable {\n  /**\n   * Activates a Modalizer and focuses the first or default element within\n   *\n   * @param elementFromModalizer - An element that belongs to a Modalizer\n   * @param noFocusFirst - Do not focus on the first element in the Modalizer\n   * @param noFocusDefault - Do not focus the default element in the Modalizre\n   */\n  focus(elementFromModalizer: HTMLElement, noFocusFirst?: boolean, noFocusDefault?: boolean): boolean;\n}\n\ninterface RestorerAPIInternal {\n  /** @internal */\n  createRestorer(element: HTMLElement, props: RestorerProps): Restorer;\n}\n\nexport interface RestorerAPI extends RestorerAPIInternal, Disposable {}\n\nexport interface Restorer extends Disposable, TabsterPart<RestorerProps> {}\n/**\n * A signature for the accessibleCheck callback from getModalizer().\n * It is called when active Modalizer sets aria-hidden on elements outsidef of it.\n *\n * @param element - The element that is about to receive aria-hidden.\n * @param activeModalizerElements - The container elements of the active modalizer.\n * @returns true if the element should remain accessible and should not receive\n * aria-hidden.\n */\nexport type ModalizerElementAccessibleCheck = (\n  element: HTMLElement,\n  activeModalizerElements?: HTMLElement[],\n) => boolean;\n\nexport interface UncontrolledProps {\n  // Normally, even uncontrolled areas should not be completely uncontrolled\n  // to be able to interact with the rest of the application properly.\n  // For example, if an uncontrolled area implements something like\n  // roving tabindex, it should be uncontrolled inside the area, but it\n  // still should be able to be an organic part of the application.\n  // However, in some cases, third party component might want to be able\n  // to gain full control of the area, for example, if it implements\n  // some custom trap focus logic.\n  // `completely` indicates that uncontrolled area must gain full control over\n  // Tab handling. If not set, Tabster might still handle Tab in the\n  // uncontrolled area, when, for example, there is an inactive Modalizer\n  // (that needs to be skipped) after the last focusable element of the\n  // uncontrolled area.\n  // WARNING: Use with caution, as it might break the normal keyboard navigation\n  // between the uncontrolled area and the rest of the application.\n  completely?: boolean;\n}\n\nexport interface DeloserOnElement {\n  deloser: Deloser;\n}\n\nexport interface RootOnElement {\n  root: Root;\n}\n\nexport interface ModalizerOnElement {\n  modalizer: Modalizer;\n}\n\nexport interface RestorerOnElement {\n  restorer: Restorer;\n}\n\nexport interface FocusableOnElement {\n  focusable: FocusableProps;\n}\n\nexport interface MoverOnElement {\n  mover: Mover;\n}\n\nexport interface GroupperOnElement {\n  groupper: Groupper;\n}\n\nexport interface UncontrolledOnElement {\n  uncontrolled: UncontrolledProps;\n}\n\nexport interface ObservedOnElement {\n  observed: ObservedElementProps;\n}\n\nexport interface OutlineOnElement {\n  outline: OutlinedElementProps;\n}\n\nexport interface SysOnElement {\n  sys: SysProps;\n}\n\nexport interface RestorerProps {\n  type: RestorerType;\n}\n\nexport type TabsterAttributeProps = Partial<{\n  deloser: DeloserProps;\n  root: RootProps;\n  uncontrolled: UncontrolledProps;\n  modalizer: ModalizerProps;\n  focusable: FocusableProps;\n  groupper: GroupperProps;\n  mover: MoverProps;\n  observed: ObservedElementProps;\n  outline: OutlinedElementProps;\n  sys: SysProps;\n  restorer: RestorerProps;\n}>;\n\nexport interface TabsterAttributeOnElement {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  string: string;\n  object: TabsterAttributeProps;\n}\n\nexport interface TabsterAugmentedAttributes {\n  [name: string]: string | null;\n}\n\nexport type TabsterOnElement = Partial<\n  RootOnElement &\n    DeloserOnElement &\n    ModalizerOnElement &\n    FocusableOnElement &\n    MoverOnElement &\n    GroupperOnElement &\n    ObservedOnElement &\n    OutlineOnElement &\n    UncontrolledOnElement &\n    SysOnElement &\n    RestorerOnElement\n>;\n\nexport interface OutlineElements {\n  container: HTMLDivElement;\n  left: HTMLDivElement;\n  top: HTMLDivElement;\n  right: HTMLDivElement;\n  bottom: HTMLDivElement;\n}\n\nexport interface TabsterElementStorageEntry {\n  tabster?: TabsterOnElement;\n  attr?: TabsterAttributeOnElement;\n  aug?: TabsterAugmentedAttributes;\n}\n\nexport interface TabsterElementStorage {\n  [uid: string]: TabsterElementStorageEntry;\n}\n\nexport type DisposeFunc = () => void;\n\nexport interface InternalAPI {\n  stopObserver(): void;\n  resumeObserver(syncState: boolean): void;\n}\n\nexport interface DummyInputObserver {\n  add(dummy: HTMLElement, callback: () => void): void;\n  remove(dummy: HTMLElement): void;\n  dispose(): void;\n  domChanged?(parent: HTMLElement): void;\n  updatePositions(\n    compute: (scrollTopLeftCache: Map<HTMLElement, { scrollTop: number; scrollLeft: number } | null>) => () => void,\n  ): void;\n}\n\ninterface TabsterCoreInternal {\n  /** @internal */\n  groupper?: GroupperAPI;\n  /** @internal */\n  mover?: MoverAPI;\n  /** @internal */\n  outline?: OutlineAPI;\n  /** @internal */\n  deloser?: DeloserAPI;\n  /** @internal */\n  modalizer?: ModalizerAPI;\n  /** @internal */\n  observedElement?: ObservedElementAPI;\n  /** @internal */\n  crossOrigin?: CrossOriginAPI;\n  /** @internal */\n  internal: InternalAPI;\n  /** @internal */\n  restorer?: RestorerAPI;\n\n  /** @internal */\n  _dummyObserver: DummyInputObserver;\n\n  // The version of the tabster package this instance is on\n  /** @internal */\n  _version: string;\n\n  // No operation flag for the debugging purposes\n  /** @internal */\n  _noop: boolean;\n\n  /** @internal */\n  storageEntry(element: HTMLElement, addremove?: boolean): TabsterElementStorageEntry | undefined;\n  /** @internal */\n  getWindow: GetWindow;\n\n  /** @internal */\n  createTabster(noRefCount?: boolean, props?: TabsterCoreProps): Tabster;\n  /** @internal */\n  disposeTabster(wrapper: Tabster, allInstances?: boolean): void;\n  /** @internal */\n  forceCleanup(): void;\n\n  /** @internal */\n  queueInit(callback: () => void): void;\n  /** @internal */\n  drainInitQueue(): void;\n  /** @internal */\n  getParent: (el: Node) => Node | null;\n}\n\nexport interface Tabster {\n  keyboardNavigation: KeyboardNavigationState;\n  focusedElement: FocusedElementState;\n  focusable: FocusableAPI;\n  root: RootAPI;\n  uncontrolled: UncontrolledAPI;\n\n  /** @internal */\n  core: TabsterCore;\n}\n\nexport interface TabsterCore\n  extends Pick<TabsterCoreProps, 'controlTab' | 'rootDummyInputs'>,\n    Disposable,\n    TabsterCoreInternal,\n    Omit<Tabster, 'core'> {}\n\nexport interface TabsterCompat {\n  attributeTransform?: <P>(old: P) => TabsterAttributeProps;\n}\n"],"names":["TabsterAttributeName","TabsterDummyInputAttributeName","DeloserEventName","ModalizerActiveEventName","ModalizerInactiveEventName","ModalizerFocusInEventName","ModalizerFocusOutEventName","ModalizerBeforeFocusOutEventName","MoverEventName","FocusInEventName","FocusOutEventName","MoveFocusEventName","MoverMoveFocusEventName","GroupperMoveFocusEventName","FocusableSelector","join","GroupperMoveFocusActions","Enter","Escape","ObservedElementAccesibilities","Any","Accessible","Focusable","RestoreFocusOrders","History","DeloserDefault","RootDefault","DeloserFirst","RootFirst","Visibilities","Invisible","PartiallyVisible","Visible","RestorerTypes","Source","Target","MoverDirections","Both","Vertical","Horizontal","Grid","GridLinear","MoverKeys","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","PageUp","PageDown","Home","End","GroupperTabbabilities","Unlimited","Limited","LimitedTrapFocus","SysDummyInputsPositions","Auto","Inside","Outside"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"AAAA;;;CAGC,GAED;;;;;;;;;;;CAWC,GAED,OAAO,MAAMA,uBAAuB,eAAe;AACnD,OAAO,MAAMC,iCAAiC,qBAAqB;AACnE,OAAO,MAAMC,mBAAmB,kBAAkB;AAClD,OAAO,MAAMC,2BAA2B,2BAA2B;AACnE,OAAO,MAAMC,6BAA6B,6BAA6B;AACvE,OAAO,MAAMC,4BAA4B,4BAA4B;AACrE,OAAO,MAAMC,6BAA6B,6BAA6B;AACvE,OAAO,MAAMC,mCAAmC,mCAAmC;AACnF,OAAO,MAAMC,iBAAiB,gBAAgB;AAC9C,OAAO,MAAMC,mBAAmB,kBAAkB;AAClD,OAAO,MAAMC,oBAAoB,mBAAmB;AAEpD,0EAA0E;AAC1E,sEAAsE;AACtE,qBAAqB;AACrB,OAAO,MAAMC,qBAAqB,oBAAoB;AAEtD,0EAA0E;AAC1E,sBAAsB;AACtB,OAAO,MAAMC,0BAA0B,0BAA0B;AACjE,2EAA2E;AAC3E,sBAAsB;AACtB,OAAO,MAAMC,6BAA6B,6BAA6B;AAEvE,OAAO,MAAMC,oBAAoB;IAC/B;IACA;IACA;IACA;IACA;IACA;IACA;CACD,CAACC,IAAI,CAAC,MAAM;AAUb,OAAO,MAAMC,2BAAqD;IAChEC,OAAO;IACPC,QAAQ;AACV,EAAE;AA0KF,OAAO,MAAMC,gCAA+D;IAC1EC,KAAK;IACLC,YAAY;IACZC,WAAW;AACb,EAAE;AAsJF,OAAO,MAAMC,qBAAyC;IACpDC,SAAS;IACTC,gBAAgB;IAChBC,aAAa;IACbC,cAAc;IACdC,WAAW;AACb,EAAE;AAqOF,OAAO,MAAMC,eAA6B;IACxCC,WAAW;IACXC,kBAAkB;IAClBC,SAAS;AACX,EAAE;AAgBF,OAAO,MAAMC,gBAAgB;IAC3BC,QAAQ;IACRC,QAAQ;AACV,EAAW;AAIX,OAAO,MAAMC,kBAAmC;IAC9CC,MAAM;IACNC,UAAU;IACVC,YAAY;IACZC,MAAM;IACNC,YAAY;AACd,EAAE;AAkFF,OAAO,MAAMC,YAAuB;IAClCC,SAAS;IACTC,WAAW;IACXC,WAAW;IACXC,YAAY;IACZC,QAAQ;IACRC,UAAU;IACVC,MAAM;IACNC,KAAK;AACP,EAAE;AAYF,OAAO,MAAMC,wBAA+C;IAC1DC,WAAW;IACXC,SAAS;IACTC,kBAAkB;AACpB,EAAE;AAyGF,OAAO,MAAMC,0BAAmD;IAC9DC,MAAM;IACNC,QAAQ;IACRC,SAAS;AACX,EAAE"}