{"version":3,"sources":["../src/createPositionManager.ts"],"sourcesContent":["import { computePosition } from '@floating-ui/dom';\nimport type { Middleware, Placement, Strategy } from '@floating-ui/dom';\nimport { isHTMLElement } from '@fluentui/react-utilities';\nimport type { PositionManager, TargetElement } from './types';\nimport { debounce, writeArrowUpdates, writeContainerUpdates } from './utils';\nimport { listScrollParents } from './utils/listScrollParents';\nimport { POSITIONING_END_EVENT } from './constants';\nimport { createResizeObserver } from './utils/createResizeObserver';\n\ninterface PositionManagerOptions {\n  /**\n   * The positioned element\n   */\n  container: HTMLElement;\n  /**\n   * Element that the container will be anchored to\n   */\n  target: TargetElement;\n  /**\n   * Arrow that points from the container to the target\n   */\n  arrow: HTMLElement | null;\n  /**\n   * The value of the css `position` property\n   * @default absolute\n   */\n  strategy: Strategy;\n  /**\n   * [Floating UI middleware](https://floating-ui.com/docs/middleware)\n   */\n  middleware: Middleware[];\n  /**\n   * [Floating UI placement](https://floating-ui.com/docs/computePosition#placement)\n   */\n  placement?: Placement;\n  /**\n   * Modifies whether popover is positioned using transform.\n   * @default true\n   */\n  useTransform?: boolean;\n  /**\n   * Disables the resize observer that updates position on target or dimension change\n   */\n  disableUpdateOnResize?: boolean;\n}\n\n/**\n * @internal\n * @returns manager that handles positioning out of the react lifecycle\n */\nexport function createPositionManager(options: PositionManagerOptions): PositionManager {\n  let isDestroyed = false;\n  const {\n    container,\n    target,\n    arrow,\n    strategy,\n    middleware,\n    placement,\n    useTransform = true,\n    disableUpdateOnResize = false,\n  } = options;\n  const targetWindow = container.ownerDocument.defaultView;\n  if (!target || !container || !targetWindow) {\n    return {\n      updatePosition: () => undefined,\n      dispose: () => undefined,\n    };\n  }\n\n  // When the dimensions of the target or the container change - trigger a position update\n  const resizeObserver = disableUpdateOnResize\n    ? null\n    : createResizeObserver(targetWindow, entries => {\n        // If content rect dimensions to go 0 -> very likely that `display: none` is being used to hide the element\n        // In this case don't update and let users update imperatively\n        const shouldUpdateOnResize = entries.every(entry => {\n          return entry.contentRect.width > 0 && entry.contentRect.height > 0;\n        });\n\n        if (shouldUpdateOnResize) {\n          updatePosition();\n        }\n      });\n\n  let isFirstUpdate = true;\n  const scrollParents: Set<HTMLElement> = new Set<HTMLElement>();\n\n  // When the container is first resolved, set position `fixed` to avoid scroll jumps.\n  // Without this scroll jumps can occur when the element is rendered initially and receives focus\n  Object.assign(container.style, { position: 'fixed', left: 0, top: 0, margin: 0 });\n\n  const forceUpdate = () => {\n    // debounced update can still occur afterwards\n    // early return to avoid memory leaks\n    if (isDestroyed) {\n      return;\n    }\n\n    if (isFirstUpdate) {\n      listScrollParents(container).forEach(scrollParent => scrollParents.add(scrollParent));\n      if (isHTMLElement(target)) {\n        listScrollParents(target).forEach(scrollParent => scrollParents.add(scrollParent));\n      }\n\n      scrollParents.forEach(scrollParent => {\n        scrollParent.addEventListener('scroll', updatePosition, { passive: true });\n      });\n\n      resizeObserver?.observe(container);\n      if (isHTMLElement(target)) {\n        resizeObserver?.observe(target);\n      }\n\n      isFirstUpdate = false;\n    }\n\n    Object.assign(container.style, { position: strategy });\n    computePosition(target, container, { placement, middleware, strategy })\n      .then(({ x, y, middlewareData, placement: computedPlacement }) => {\n        // Promise can still resolve after destruction\n        // early return to avoid applying outdated position\n        if (isDestroyed) {\n          return;\n        }\n\n        writeArrowUpdates({ arrow, middlewareData });\n        writeContainerUpdates({\n          container,\n          middlewareData,\n          placement: computedPlacement,\n          coordinates: { x, y },\n          lowPPI: (targetWindow?.devicePixelRatio || 1) <= 1,\n          strategy,\n          useTransform,\n        });\n\n        container.dispatchEvent(new CustomEvent(POSITIONING_END_EVENT));\n      })\n      .catch(err => {\n        // https://github.com/floating-ui/floating-ui/issues/1845\n        // FIXME for node > 14\n        // node 15 introduces promise rejection which means that any components\n        // tests need to be `it('', async () => {})` otherwise there can be race conditions with\n        // JSDOM being torn down before this promise is resolved so globals like `window` and `document` don't exist\n        // Unless all tests that ever use `usePositioning` are turned into async tests, any logging during testing\n        // will actually be counter productive\n        if (process.env.NODE_ENV === 'development') {\n          // eslint-disable-next-line no-console\n          console.error('[usePositioning]: Failed to calculate position', err);\n        }\n      });\n  };\n\n  const updatePosition = debounce(() => forceUpdate());\n\n  const dispose = () => {\n    isDestroyed = true;\n\n    if (targetWindow) {\n      targetWindow.removeEventListener('scroll', updatePosition);\n      targetWindow.removeEventListener('resize', updatePosition);\n    }\n\n    scrollParents.forEach(scrollParent => {\n      scrollParent.removeEventListener('scroll', updatePosition);\n    });\n    scrollParents.clear();\n\n    resizeObserver?.disconnect();\n  };\n\n  if (targetWindow) {\n    targetWindow.addEventListener('scroll', updatePosition, { passive: true });\n    targetWindow.addEventListener('resize', updatePosition);\n  }\n\n  // Update the position on initialization\n  updatePosition();\n\n  return {\n    updatePosition,\n    dispose,\n  };\n}\n"],"names":["createPositionManager","options","isDestroyed","container","target","arrow","strategy","middleware","placement","useTransform","disableUpdateOnResize","targetWindow","ownerDocument","defaultView","updatePosition","undefined","dispose","resizeObserver","createResizeObserver","entries","shouldUpdateOnResize","every","entry","contentRect","width","height","isFirstUpdate","scrollParents","Set","Object","assign","style","position","left","top","margin","forceUpdate","listScrollParents","forEach","scrollParent","add","isHTMLElement","addEventListener","passive","observe","computePosition","then","x","y","middlewareData","computedPlacement","writeArrowUpdates","writeContainerUpdates","coordinates","lowPPI","devicePixelRatio","dispatchEvent","CustomEvent","POSITIONING_END_EVENT","catch","err","process","env","NODE_ENV","console","error","debounce","removeEventListener","clear","disconnect"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}